- 动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。实际上，子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。
	- 分治算法递归地将原问题划分为多个**相互独立的子问题，直至最小子问题**，并在回溯中合并子问题的解，最终得到原问题的解。
	- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以**将每个决策步骤之前的子序列看作一个子问题**。
	- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在**分解过程中会出现许多重叠子问题**。
- 动态规划问题的特性：#card
  card-last-score:: nil
  card-repeats:: 0
  card-next-schedule:: nil
  card-last-interval:: -1
  id:: 67a708d6-0666-4c51-9821-e2b7263b88d7
  card-ease-factor:: 2.5
  card-last-reviewed:: nil
	- 最优子结构
	  id:: 67a709fb-6fa4-453a-bb29-81aa473aa1d3
	  card-last-interval:: -1
	  card-repeats:: 1
	  card-ease-factor:: 2.5
	  card-next-schedule:: 2025-02-08T16:00:00.000Z
	  card-last-reviewed:: 2025-02-08T08:08:32.468Z
	  card-last-score:: 1
		- **原问题的最优解是从子问题的最优解构建得来的**
	- 无后效性
	  id:: 67a70a07-ae9e-44f5-9f8c-0604c15faef3
	  card-last-interval:: -1
	  card-repeats:: 1
	  card-ease-factor:: 2.5
	  card-next-schedule:: 2025-02-08T16:00:00.000Z
	  card-last-reviewed:: 2025-02-08T08:08:33.802Z
	  card-last-score:: 1
		- **给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关**
- 解题步骤：
	- 1、问题判断
		- 判断一个问题是不是动态规划问题，总的来说，如果一个问题包含重叠子问题、 ((67a709fb-6fa4-453a-bb29-81aa473aa1d3)) ，并满足 ((67a70a07-ae9e-44f5-9f8c-0604c15faef3)) ，那么它通常适合用动态规划求解。
		- 然而，我们很难从问题描述中直接提取出这些特性。因此我们通常会放宽条件，如果一个问题满足**决策树模型**，并具有较为明显的**“加分项”**，我们就可以假设它是一个动态规划问题，并在求解过程中验证它。
		- 决策树模型：问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列。
		- “加分项”：
			- 问题包含最大（小）或最多（少）等最优化描述。
			- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。
	- 2、求解步骤
		- 描述每轮决策，定义状态从而得到`dp`表：每个状态都对应一个子问题，我们会定义一个 `dp` 表来存储所有子问题的解，状态的每个独立变量都是 `dp` 表的一个维度。从本质上看，`dp` 表是状态和子问题的解之间的映射。
		- **找出最优子结构，推导出状态转移方程**：根据定义好的`dp`表，思考原问题和子问题的关系，找出通过子问题的最优解来构造原问题的最优解的方法，即最优子结构。一旦我们找到了最优子结构，就可以使用它来构建出状态转移方程。
		- 确定边界条件和状态转移顺序：边界条件在动态规划中用于初始化`dp`表，在搜索中用于剪枝。状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确地计算出来。
- 经典问题：
- 类型:
	- 斐波那契类型 [[斐波那契型]]
	-