- 来源：
	- 斐波那契数列：**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
	  ```
	  F(0) = 0，F(1) = 1
	  F(n) = F(n - 1) + F(n - 2)，其中 n > 1
	  ```
- 斐波那契数列明显满足 ((67a709fb-6fa4-453a-bb29-81aa473aa1d3)) 和 ((67a70a07-ae9e-44f5-9f8c-0604c15faef3))，因此可以使用动态规划来解决，且该种解决方案代表了一种范式，即`dp`表是一个数组，子结构的解存储在数组中。
- **递归**：
	- [[draws/2025-02-17-11-20-26.excalidraw]]
	- 可以看到，使用递归的方法会导致许多的重复计算，导致计算效率大大降低。
	- code:
		- ```
		  class Solution {
		  public:
		      int fib(int n) {
		          if(n==0 || n==1){
		              return n;
		          }
		          return fib(n-1)+fib(n-2);
		      }
		  };
		  ```
		- 时间复杂度：`O()`, 空间复杂度：`O(1)`
			- 怎么分析递归的时间复杂度？ [[card]]
				- TODO
- 对于斐波那契型的动态规划问题，使用一维数组可以解决，但是相较于递归方法的空间复杂度而言，一维数组的内存消耗较大，可以采用一些方法对其进行优化。
	- 如何优化斐波那契型动态规划的空间复杂度？ [[card]]
		- TODO