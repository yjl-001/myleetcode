- 题目:打家劫舍 [[DM(DynamicProgramming)]] [[斐波那契型]]
	- 描述:
		- 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
		- 给定一个代表每个房屋存放金额的非负整数数组，计算你** 不触动警报装置的情况下 **，一夜之内能够偷窃到的最高金额。
	- 分析 & 方案:
		- 假设`n=nums.size()`表示共有`n`个房屋, 当`n=1`时,小偷能偷窃的最大金额为`nums[0]`.当`n=2`时,小偷能偷窃到最大金额为`max{nums[0], nums[1]}`
		- 当`n>2`时,将房屋标号为`1, 2, ..., n`,设`dp[i]`表示小偷偷窃前`i`个房屋能偷窃到的最大金额,根据题目,当小偷偷窃到房屋`i`时,
			- 选择出手,那么就不能偷窃第`i-1`号房屋,偷窃金额为前`i-2`间房屋的最高金额与第`i`间房屋的金额之和.
			- 选择不出手(已经偷窃了`i-1`号房屋),偷窃金额为前`i-1`间房屋的最高金额.
		- 状态转移方程为:
		  $$dp[i]=max\{dp[i-2]+nums[i-1], dp[i-1]\}, i > 2$$
		- 边界条件:
		  $$dp[0] = 0$$
		  $$dp[1] = nums[0]$$
	- code:
		- ```
		  class Solution {
		  public:
		      int rob(vector<int>& nums) {
		              int n = nums.size();
		              if (n==1){
		                  return nums[0];
		              }
		              vector<int> dp(n+1);
		              dp[0] = 0;
		              dp[1] = nums[0];
		              for(int i=2; i<=n; i++){
		                  dp[i] = max(dp[i-2]+nums[i-1], dp[i-1]);
		              }
		              return dp[n];
		      }
		  };
		  ```
		- 时间复杂度：`O(n)`，空间复杂度`O(n)`